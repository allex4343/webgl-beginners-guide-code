<html>

<head>
<title>WebGL Beginner's Guide - Chapter 3 - Nissan GTS with Shading</title>

<!-- CSS Styles //-->
<link href='css/style.css' 		type='text/css' rel='stylesheet'>
<link href='css/desert.css' 	type='text/css' rel='stylesheet'/>
<link href='css/colorpicker.css' 	type='text/css' rel='stylesheet'/>
<link href='css/smoothness/jquery-ui-1.8.13.custom.css' type='text/css' rel='stylesheet' />

<!-- JavaScript Libraries //-->
<script type='text/javascript' src='js/glMatrix-0.9.5.min.js'></script>
<script type='text/javascript' src='js/jquery-1.5.1.min.js'></script>
<script type='text/javascript' src='js/jquery-ui-1.8.13.custom.min.js'></script> 
<script type='text/javascript' src='js/prettify.js'></script>
<script type='text/javascript' src='js/utils.js'></script>
<script type='text/javascript' src='js/colorpicker.js'></script>
<script type='text/javascript' src='js/codeview.js'></script>


<!-- Fragment Shader //-->
<script id="shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision highp float;
    #endif
    
    varying vec3 vColor;
    
    void main(void) {
        gl_FragColor = vec4(vColor, 1.0);
    }
</script>

<!-- Vertex Shader //-->
<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat4 uNMatrix;
    
    //Uniforms that define lighting model
    uniform vec3 uLightingDirection;
    uniform vec3 uAmbientColor;
    uniform vec3 uDirectionalColor;
    uniform vec3 uObjectColor;
    
    varying vec3 vColor;

    void main(void) {
        vec4 transformedNormal = uNMatrix * vec4(aVertexNormal, 1.0);
        float directionalLightWeighting = max(dot(transformedNormal.xyz,uLightingDirection),0.0);
        vColor = uObjectColor * (uAmbientColor + uDirectionalColor * directionalLightWeighting);
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    }
</script>

<script id="code-js" type="text/javascript">
    
var gl = null; // WebGL context
var prg = null; // The program (shaders)
var c_width = 0; // Variable to store the width of the canvas
var c_height = 0; // Variable to store the height of the canvas

var part = [];    //PARTS LOADED
var vbo = [];
var ibo = [];
var nbo = [];


var mvMatrix = mat4.create(); // The Model-View matrix
var pMatrix = mat4.create(); // The projection matrix
var nMatrix = mat4.create(); // The normal matrix

var angle = 0;

    
/*
* The program contains a series of instructions that tell the Graphic Processing Unit (GPU)
* what to do with every vertex and fragment that we pass it. (more about this on chapter 3)
* The vertex shader and the fragment shader together are called the program.
*/
function initProgram() {
    var fgShader = utils.getShader(gl, "shader-fs");
    var vxShader = utils.getShader(gl, "shader-vs");

    prg = gl.createProgram();
    gl.attachShader(prg, vxShader);
    gl.attachShader(prg, fgShader);
    gl.linkProgram(prg);

    if (!gl.getProgramParameter(prg, gl.LINK_STATUS)) {
        alert("Could not initialise shaders");
    }

    gl.useProgram(prg);

    prg.aVertexPosition     = gl.getAttribLocation(prg, "aVertexPosition");
    prg.uPMatrix            = gl.getUniformLocation(prg, "uPMatrix");
    prg.uMVMatrix           = gl.getUniformLocation(prg, "uMVMatrix");
    
    //Lighting model
    prg.aVertexNormal       = gl.getAttribLocation(prg, "aVertexNormal");
    
    
    prg.uNMatrix            = gl.getUniformLocation(prg,"uNMatrix");
    prg.uAmbientColor       = gl.getUniformLocation(prg,"uAmbientColor");
    prg.uLightingDirection  = gl.getUniformLocation(prg,"uLightingDirection");
    prg.uDirectionalColor   = gl.getUniformLocation(prg,"uDirectionalColor");
    prg.uObjectColor        = gl.getUniformLocation(prg,"uObjectColor");
}	

function initLights(){
    /**
     * try x = 1, y = 0, z = 0 to see a really dramatic light effect 
     * try x = 0, y = 0, z = -1 this is when the light source is on the other side
     * 
     */
    gl.uniform3f(prg.uLightingDirection, 0.0, 0.0, 1.0);
    gl.uniform3f(prg.uDirectionalColor,0.6 ,0.6, 0.6);
    gl.uniform3f(prg.uAmbientColor,0.02,0.02,0.02);
    gl.uniform3f(prg.uObjectColor,1.0,1.0,1.0);
}	
    
/**
* Creates an AJAX request to load a model asynchronously
*/
function loadModel(){
  for(var i = 1; i < 179; i++){
        var filename = 'models/nissan_gts/pr'+i+'.json';
        loadPart(filename);
   }
 
 
}

function loadPart(filename){
    var request = new XMLHttpRequest();
    console.info('Requesting ' + filename);
    request.open("GET",filename);
    
    request.onreadystatechange = function() {
      if (request.readyState == 4) {
        if(request.status == 404) {
            console.info(filename + ' does not exist');
         }
        else {
            handleLoadedPart(filename,JSON.parse(request.responseText));
        }
      }
    }
    request.send();
}

/**
* Creates the buffers that contain the geometry of the model
*/
function handleLoadedPart(filename,payload) {
    
    console.info(filename + ' has been retrieved from the server');
    
    var vertexBufferObject = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBufferObject);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(payload.vertices), gl.STATIC_DRAW);
    
           
    var normalBufferObject = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, normalBufferObject);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(createNormals(payload)), gl.STATIC_DRAW);
    
    var indexBufferObject = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferObject);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(payload.indices), gl.STATIC_DRAW);
        
    
    vbo.push(vertexBufferObject);
    ibo.push(indexBufferObject);
    nbo.push(normalBufferObject);
    
    
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ARRAY_BUFFER,null);
    
    part.push(payload);
}


function createNormals(payload){
    //face normal calculation
    var vs = payload.vertices;
    var ind = payload.indices;
    
    var x=0; 
    var y=1;
    var z=2;
    
    var ns = [];
    for(var i=0;i<vs.length;i=i+3){ //for each vertex, initialize normal x, normal y, normal z
        ns[i+x]=0.0;
        ns[i+y]=0.0;
        ns[i+z]=0.0;
    }
    
    for(var i=0;i<ind.length;i=i+3){ //we work on triads of vertices to calculate normals so i = i+3 (i = indices index)
        var v1 = [];
        var v2 = [];
        var normal = [];	
        //p2 - p1
        v1[x] = vs[3*ind[i+2]+x] - vs[3*ind[i+1]+x];
        v1[y] = vs[3*ind[i+2]+y] - vs[3*ind[i+1]+y];
        v1[z] = vs[3*ind[i+2]+z] - vs[3*ind[i+1]+z];
        //p0 - p1
        v2[x] = vs[3*ind[i]+x] - vs[3*ind[i+1]+x];
        v2[y] = vs[3*ind[i]+y] - vs[3*ind[i+1]+y];
        v2[z] = vs[3*ind[i]+z] - vs[3*ind[i+1]+z];
        //cross product
        normal[x] = v1[y]*v2[z] - v1[z]*v2[y];
        normal[y] = v1[z]*v2[x] - v1[x]*v2[z];
        normal[z] = v1[x]*v2[y] - v1[y]*v2[x];
        for(j=0;j<3;j++){ //update the normals of that triangle
            ns[3*ind[i+j]+x] =  ns[3*ind[i+j]+x] + normal[x];
            ns[3*ind[i+j]+y] =  ns[3*ind[i+j]+y] + normal[y];
            ns[3*ind[i+j]+z] =  ns[3*ind[i+j]+z] + normal[z];
        }
    }
    //normalize the result
    for(var i=0;i<vs.length;i=i+3){ //the increment here is because each vertex occurs with an offset of 3 in the array (due to x, y, z contiguous values)
    
        var nn=[];
        nn[x] = ns[i+x];
        nn[y] = ns[i+y];
        nn[z] = ns[i+z];
        
        var len = Math.sqrt((nn[x]*nn[x])+(nn[y]*nn[y])+(nn[z]*nn[z]));
        if (len == 0) len = 1.0;
        
        nn[x] = nn[x]/len;
        nn[y] = nn[y]/len;
        nn[z] = nn[z]/len;
        
        ns[i+x] = nn[x];
        ns[i+y] = nn[y];
        ns[i+z] = nn[z];
    }
    
    return ns;
}
    
/**
* Draws the scene
*/
function drawScene(){
    
    gl.clearColor(0.3, 0.3, 0.3, 1.0);
    gl.enable(gl.DEPTH_TEST);
    
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.viewport(0,0,c_width, c_height);
    
    mat4.perspective(45, c_width / c_height, 10, 10000.0, pMatrix);
    mat4.identity(mvMatrix);	
    mat4.translate(mvMatrix, [0.0, -200.0, -2000.0]); //Sets the camera to a reasonable distance to view the part
    mat4.rotate(mvMatrix, 30 * Math.PI /180, [1,0,0]);
    mat4.rotate(mvMatrix, angle * Math.PI / 180, [0, 1, 0]);
    
    gl.uniformMatrix4fv(prg.uPMatrix, false, pMatrix);
    gl.uniformMatrix4fv(prg.uMVMatrix, false, mvMatrix);
    
    mat4.set(mvMatrix, nMatrix);
    mat4.inverse(nMatrix);
    mat4.transpose(nMatrix);
    
    gl.uniformMatrix4fv(prg.uNMatrix, false, nMatrix);
    
    
    
    
    for(var i = 0; i < part.length; i++){
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo[i]);
        gl.vertexAttribPointer(prg.aVertexPosition, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(prg.aVertexPosition);
        
        gl.bindBuffer(gl.ARRAY_BUFFER, nbo[i]);
        gl.vertexAttribPointer(prg.aVertexNormal, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(prg.aVertexNormal);
    
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo[i]);
        gl.drawElements(gl.TRIANGLES, part[i].indices.length, gl.UNSIGNED_SHORT,0);
    }
    
}




var lastTime = 0;

/**
* Updates the angle of rotation by a little bit each time
*/
function animate() {
    var timeNow = new Date().getTime();
    if (lastTime != 0) {
        var elapsed = timeNow - lastTime;
        angle += (90 * elapsed) / 10000.0;
    }
    lastTime = timeNow;
}

/**
* Render Loop
*/
function renderLoop() {
    utils.requestAnimFrame(renderLoop);
    drawScene();
    animate();
}
/**
* Executes the WebGL application
* This function is invoked on the onLoad event of the webpage. 
*/
function runWebGLApp(){
    //Obtains a WebGL context
    gl = utils.getGLContext('canvas-element-id');
    //Initializes the program (shaders). More about this on chapter 3!
    initProgram();
    //Init Lights!
    initLights();
    //Initializes the buffers that we are going to use to draw the part (vertex buffer and index buffer)
    loadModel();
    //Draws the part!
    renderLoop();
}
</script>
</head>

<body onLoad='runWebGLApp()'>
<div id='top'>
    <h1>WebGL Beginner's Guide - Chapter 3</h1>
    <h2>Nissan GTX - Simple Shading Model</h2>
    <div id='logo-packt'><img src='packt.gif'/></div>
    <p>This example shows how to apply a simple lighting model to the Nissan GTX model that we saw at the end of Chapter 2. </p>
    
        
</div>

<div id='contents'>
    <div id='canvasContainer'>
        <canvas id='canvas-element-id' width='480' height='400'>
            Your browser does not support the HTML5 canvas element.
        </canvas>
    </div>
</div>

<div id='bottom' class='t_table'>
<div class='t_row'>
    <div class='t_cell'>Shininess:</div>
    <div id='slider-shininess'></div>
    <div id='slider-shininess-value' class='t_cell' >200</div>
    <div class='t_cell' style='width:20px;'></div>
    <div class='t_cell'>Object Color:</div>
    <div class='t_cell'><div id='colorSelector'><div style='background-color:rgb(128,204,26)'></div></div></div>
</div>
</div>
<script>cview.run(cview.MODE_VIEW);</script>
<script> 
function updateShininess(){
    var v = $('#slider-shininess').slider("value");
    gl.uniform1f(prg.uShininess, v);
    $('#slider-shininess-value').html(v);
}

function updateObjectColor(r,g,b){
    gl.uniform3f(prg.uObjectColor, r,g,b);
}

$('#slider-shininess').slider({value:200, min:1, max:300, step:1, slide:updateShininess});


$('#colorSelector').ColorPicker({
    onSubmit: function(hsb, hex, rgb, el) {
			$(el).val(hex);
			$(el).ColorPickerHide();
			
	},
	color: '#00ff00',
    onShow: function (colpkr) {
        $(colpkr).fadeIn(500);
        return false;
    },
    onHide: function (colpkr) {
        $(colpkr).fadeOut(500);
        return false;
    },
    onChange: function (hsb, hex, rgb) {
        $('#colorSelector div').css('backgroundColor', '#' + hex);
        updateObjectColor(rgb.r/256,rgb.g/256,rgb.b/256);
    },
    
    onBeforeShow: function (colpkr) {
			$(this).ColorPickerSetColor('rgb(0.5,0.8,0.1)');
		}
	})
	

</script>
</html>
